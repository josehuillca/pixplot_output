<!DOCTYPE html>
<html lang='en'>

  <!-- version: VERSION_NUMBER -->
  <script type='x-shader/x-vertex' id='vertex-shader'>
  /**
  * The vertex shader's main() function must define `gl_Position`,
  * which describes the position of each vertex in screen coordinates.
  *
  * To do so, we can use the following variables defined by Three.js:
  *   uniform mat4 projectionMatrix - maps camera space into screen space
  *   uniform mat4 modelViewMatrix - combines:
  *     model matrix: maps a point's local coordinate space into world space
  *     view matrix: maps world space into camera space
  *
  * `attributes` can vary from vertex to vertex and are defined as arrays
  *   with length equal to the number of vertices. Each index in the array
  *   is an attribute for the corresponding vertex. Each attribute must
  *   contain n_vertices * n_components, where n_components is the length
  *   of the given datatype (e.g. for a vec2, n_components = 2; for a float,
  *   n_components = 1)
  * `uniforms` are constant across all vertices
  * `varyings` are values passed from the vertex to the fragment shader
  *
  * For the full list of uniforms defined by three, see:
  *   https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
  **/

  #version 100
  #define SHADER_NAME instancedVertex
  #define SELECTING

  // set float precision
  precision mediump float;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;
  uniform vec3 cameraPosition;
  uniform float scale;
  uniform float scaleTarget;
  uniform float transitionPercent;
  uniform float scaleTransitionPercent;
  uniform float borderWidth;
  uniform float delay;

  attribute vec3 pos0;          // x y z position offsets for an instance
  attribute vec3 pos1;          // x y z position to which we're transitioning
  attribute vec3 color;         // unique color for cell; used for raycasting
  attribute float width;        // px width of cell in lod texture
  attribute float height;       // px height of cell in lod texture
  attribute vec2 offset;        // px offset in tex from left, top
  attribute float opacity;      // opacity value for cell
  attribute float selected;     // 1 if the cell is selected else 0
  attribute float textureIndex; // index of an instance's texture among all textures

  attribute vec3 myborderColor; // HUILLCA color de borde da imagem

  varying vec3 vColor;          // cell color
  varying vec2 vOffset;         // px of cell offset left, top in texture
  varying float vWidth;         // px width of cell in lod texture
  varying float vHeight;        // px height of cell in lod texture
  varying float vOpacity;       // cell opacity
  varying float vSelected;      // 1 if this cell is selected else 0
  varying float vTextureIndex;  // cell texture idx (varyings can't be int)
  varying vec3 vMyborderColor;  // HUILLCA

  void main() {
    // pass varyings to fragment shader
    vTextureIndex = textureIndex;
    vColor = color;
    vWidth = width;
    vHeight = height;
    vOffset = offset;
    vOpacity = opacity;
    vSelected = selected;
    vMyborderColor = myborderColor;

    // determine how far this point has proceeded in its transition
    float delayX = (pos1.x + 1.0) / 2.0;
    float delayY = (pos0.y + 1.0) / 2.0;
    // pos0 has domains -1:1, so the delay sum above is <= 2.0
    float d = ((delayX + delayY) / 2.0) * delay;

    float percent = clamp(transitionPercent - d, 0.0, 1.0);

    // set point position as a mixture between the position + target
    vec3 pos = mix(pos0, pos1, smoothstep(0., 1., percent));
    vec4 world = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * world;

    // use the unscaled point position and camera position to set point size
    float s = mix(scale, scaleTarget, percent);
    float pointSize = s / -world.z;

    if (selected > 0.5) {
      gl_PointSize = pointSize + (pointSize * borderWidth);
    } else {
      gl_PointSize = pointSize;
    }
  }
  </script>

  <script type='x-shader/x-fragment' id='fragment-shader'>
  /**
  * The fragment shader's main() function must define `gl_FragColor`,
  * which describes the pixel color of each pixel on the screen.
  *
  * To do so, we can use uniforms passed into the shader and varyings
  * passed from the vertex shader.
  *
  * Attempting to read a varying not generated by the vertex shader will
  * throw a warning but won't prevent shader compiling.
  **/

  #version 100
  #define SHADER_NAME instancedFragment
  #define SELECTING

  precision mediump float;

  uniform float useColor;
  uniform float cellAtlasPxPerSide;
  uniform float lodAtlasPxPerSide;
  uniform float cellPxHeight;
  uniform float lodPxHeight;
  uniform float borderWidth;
  uniform vec3 borderColor;

  varying vec3 vColor;         // cell's color (for gpu picking)
  varying vec2 vOffset;        // cell's offset in px from left, top of tex
  varying float vWidth;        // cell's width in lod tex in px
  varying float vHeight;       // cell's height in lod tex in px
  varying float vOpacity;      // cell's opacity
  varying float vSelected;     // cell's presence (>0.5) or absence (<0.5) from selection
  varying float vTextureIndex; // cell's texture index

  varying vec3 vMyborderColor;  // HUILLCA

  #ifndef SELECTING
    uniform sampler2D textures[N_TEXTURES]; // array of sampler2Ds
    uniform sampler2D lodTexture; // single sampler2D
  #endif

  void main() {
    // HUILLCA
    //borderColor = vMyborderColor;

    // is this cell a LOD cell?
    bool isLod = vTextureIndex < -0.5;

    // get the width of the border on each side of the cell
    float borderW = borderWidth / 2.0;

    // find the width and height of this cell in its texture (in px)
    float w = isLod ? vWidth : vWidth/vHeight*cellPxHeight;
    float h = isLod ? vHeight : cellPxHeight;

    // find the length of the cell in its longest dimension (in px)
    float big = max(w, h);

    // set boolean indicating whether to center cells
    bool center = true;

    // find min, max vals of 0:1 scaled x axis to be textured
    float x0 = center ? (big-w)/2.0/big : 0.0;
    float x1 = center ? (w/big)+x0 : w / big;

    // find min, max vals of 0:1 scaled y axis to be textured
    float y0 = center ? (big-h)/2.0/big : 0.0;
    float y1 = center ? (h/big)+y0 : h / big;

    // clip the cell to center the texture on the x axis
    if (h > w && (gl_PointCoord.x < x0 || gl_PointCoord.x > x1)) discard;

    // if this cell's image is landscape clip bottom margin
    else if (w > h && gl_PointCoord.y < y0 || gl_PointCoord.y > y1) discard;

    // if this shader is using vColor attributes skip texture processing
    if (int(useColor) == 1) gl_FragColor = vec4(vColor, 1.0);

    // this cell should be textured
    else {

      // check if the current pointcoord position is within the border
      // vSelected > 0.5 &&  HUILLCA
      if ((gl_PointCoord.x < x0 + borderW ||
          gl_PointCoord.x > x1 - borderW ||
          gl_PointCoord.y < y0 + borderW ||
          gl_PointCoord.y > y1 - borderW)) {
        gl_FragColor = vec4(vMyborderColor, 1.0);

      } else {

        // get the x and y positions to sample for this cell's texture
        float x = center ? gl_PointCoord.x - x0 : gl_PointCoord.x;
        float y = center ? gl_PointCoord.y - y0 : gl_PointCoord.y;

        // scale the x and y positions to the size of the texture
        vec2 uv = vOffset + vec2(x, y) * big;

        // set variables consumed by fragment tree below
        vec2 scaledUv = isLod ? uv/lodAtlasPxPerSide : uv/cellAtlasPxPerSide;
        int textureIndex = isLod ? -1 : int(vTextureIndex);

        // target to be replaced by texture tree
        TEXTURE_LOOKUP_TREE

        gl_FragColor = mix(gl_FragColor, vec4(0.0), 1.0-vOpacity);
        gl_FragColor.a = 1.0;

        //if (vSelected > 0.5) HUILLCA
        gl_FragColor = mix(gl_FragColor, vec4(vMyborderColor, 1.0), 0.15);
      }
    }
  }
  </script>

  

  <head>
    <link rel='stylesheet' type='text/css' href='assets/css/no-ui-slider.css'>
    <link rel='stylesheet' type='text/css' href='assets/css/style.css'>
    <title>Test</title>
    <meta charset='utf-8'/>
  </head>
  <body>

    <!-- Loader -->
    <div id='loader-scene'>
      <p class='welcome'>Wait loadding ...</p>
      <div class='loader-container'>
        <div class='loader-icon'>
          <div class='blocks'>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
          </div>
        </div>
        <div id='loader-text'>
          <span id='progress'>0%</span>
        </div>
      </div>
      <button id='enter-button'>Enter</button>
    </div>

    <!-- Canvas -->
    <div id='canvas-container'>
      <div id='jitter-container'>
        <input type='checkbox' id='jitter-input'>
        <label>Jitter</label>
      </div>
      <div id='canvas-target'>
        <canvas id='pixplot-canvas' />
      </div>
    </div>
    <!-- Hotspot Navigation Centroides-->
    <nav>
      <div class='nav-inner no-highlight'>
        <div id='hotspots'></div>
        <script type='text/html' id='hotspot-template'>
          <% _.forEach(hotspots, function(hotspot) { %>
            <div class='hotspot'>
              <img src='data/thumbs/<%= hotspot.img %>' class='image-cluster-<%= hotspot.label %>'>
              <div style="display: none"><%= hotspot.label %></div>
            </div>
          <% }); %>
        </script>
      </div>
    </nav>
    Hi - canvas arriba!

    <div id='selection-icons' class='no-highlight'>
      <input id='pointsize-range-input' min='0' max='0.03' value='0' step='0.00001' type='range' />
      <img id='pan' src='assets/images/icons/pan.svg' class='active' />
      <img id='select' src='assets/images/icons/lasso.png' class='' />
    </div>

    <!-- Webgl / Noscript Warnings -->
    <div id='webgl-not-available'>
      <div class='browser-message'>Sorry, your browser is not able to load a WebGL scene currently. Please check your browser settings and try again.</div>
    </div>
    <noscript>
      <span class='browser-message'>Sorry, your browser is not able to load a WebGL scene currently. Please enable JavaScript and try again.</span>
    </noscript>
    
    <script type='text/javascript' src='assets/vendor/dist/three.min.js'></script>

    <script type='text/javascript' src='assets/vendor/dist/lodash.min.js'></script>

    <script type='text/javascript' src='assets/vendor/dist/tweenlite.min.js'></script>
    <script type='text/javascript' src='assets/vendor/dist/trackball-controls.min.js'></script>

    <script type='text/javascript' src='assets/js/tsne.js'></script>
    
  </body>
</html>